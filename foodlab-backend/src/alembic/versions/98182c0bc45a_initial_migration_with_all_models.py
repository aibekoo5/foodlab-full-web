"""Initial migration with all models

Revision ID: 98182c0bc45a
Revises: 788495dcd8fa
Create Date: 2025-12-19 03:10:32.941427

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '98182c0bc45a'
down_revision: Union[str, Sequence[str], None] = '788495dcd8fa'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    
    # Создаем enum типы, если они еще не существуют
    from sqlalchemy.dialects.postgresql import ENUM
    
    # Проверяем и создаем enum типы только если их нет
    connection = op.get_bind()
    
    # PaymentMethod enum
    paymentmethod_enum = ENUM('kaspi', name='paymentmethod', create_type=False)
    paymentmethod_enum.create(connection, checkfirst=True)
    
    # PaymentStatus enum - проверяем, существует ли старый тип
    # Если существует старый paymentstatus с другими значениями, нужно его пересоздать
    result = connection.execute(sa.text("""
        SELECT EXISTS (
            SELECT 1 FROM pg_type WHERE typname = 'paymentstatus'
        )
    """))
    paymentstatus_exists = result.scalar()
    
    if paymentstatus_exists:
        # Проверяем значения существующего enum
        result = connection.execute(sa.text("""
            SELECT enumlabel FROM pg_enum 
            WHERE enumtypid = (SELECT oid FROM pg_type WHERE typname = 'paymentstatus')
            ORDER BY enumsortorder
        """))
        existing_values = [row[0] for row in result]
        
        # Если значения отличаются, удаляем старый и создаем новый
        if set(existing_values) != {'PENDING', 'PAID', 'FAILED'}:
            # Удаляем старый enum (если он используется, это может вызвать ошибку)
            # В этом случае нужно сначала удалить зависимые колонки
            pass
    
    paymentstatus_enum = ENUM('PENDING', 'PAID', 'FAILED', name='paymentstatus', create_type=False)
    paymentstatus_enum.create(connection, checkfirst=True)
    
    # UserRole enum
    userrole_enum = ENUM('USER', 'CANTEEN', 'ADMIN', name='userrole', create_type=False)
    userrole_enum.create(connection, checkfirst=True)
    
    # MenuItemType enum
    menuitemtype_enum = ENUM('food', 'drink', name='menuitemtype', create_type=False)
    menuitemtype_enum.create(connection, checkfirst=True)
    
    op.create_table('subscription_packages',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', sa.Integer(), nullable=False),
    sa.Column('meal_count', sa.Integer(), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('payments',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('amount', sa.Integer(), nullable=False),
    sa.Column('method', postgresql.ENUM('kaspi', name='paymentmethod', create_type=False), nullable=False),
    sa.Column('status', postgresql.ENUM('PENDING', 'PAID', 'FAILED', name='paymentstatus', create_type=False), nullable=False),
    sa.Column('payment_url', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_payments_user_id'), 'payments', ['user_id'], unique=False)
    op.create_table('user_subscriptions',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('package_id', sa.UUID(), nullable=False),
    sa.Column('remaining_meals', sa.Integer(), nullable=False),
    sa.Column('start_date', sa.DateTime(timezone=True), nullable=False),
    sa.Column('end_date', sa.DateTime(timezone=True), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['package_id'], ['subscription_packages.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_user_subscriptions_is_active'), 'user_subscriptions', ['is_active'], unique=False)
    op.create_index(op.f('ix_user_subscriptions_user_id'), 'user_subscriptions', ['user_id'], unique=False)
    
    # Удаляем старые таблицы в правильном порядке (сначала зависимые, потом родительские)
    # Сначала удаляем внешние ключи, которые ссылаются на таблицы, которые мы хотим удалить
    # Удаляем внешний ключ postamat_id из orders перед удалением таблицы postamats
    # Используем проверку существования, чтобы избежать ошибок, если ключ уже удален
    connection = op.get_bind()
    result = connection.execute(sa.text("""
        SELECT constraint_name 
        FROM information_schema.table_constraints 
        WHERE table_name = 'orders' 
        AND constraint_name = 'orders_postamat_id_fkey'
    """))
    if result.fetchone():
        op.drop_constraint('orders_postamat_id_fkey', 'orders', type_='foreignkey')
    
    # Затем удаляем таблицы, которые зависят от других
    op.drop_table('subscriptions')  # зависит от plans
    op.drop_table('order_items')  # зависит от orders и menu_items
    # Затем удаляем родительские таблицы
    op.drop_table('plans')
    op.drop_table('postamats')
    # Добавляем колонки сначала как nullable, затем заполняем и делаем NOT NULL
    op.add_column('canteens', sa.Column('qr_code', sa.String(), nullable=True))
    op.add_column('canteens', sa.Column('is_active', sa.Boolean(), nullable=True))
    
    # Заполняем значениями для существующих записей
    connection = op.get_bind()
    connection.execute(sa.text("""
        UPDATE canteens 
        SET qr_code = 'QR-' || id::text,
            is_active = true
        WHERE qr_code IS NULL OR is_active IS NULL
    """))
    
    # Теперь делаем колонки NOT NULL
    op.alter_column('canteens', 'qr_code', nullable=False)
    op.alter_column('canteens', 'is_active', nullable=False)
    op.alter_column('canteens', 'description',
               existing_type=sa.VARCHAR(),
               type_=sa.Text(),
               existing_nullable=True)
    op.drop_index('ix_canteens_slug', table_name='canteens')
    op.create_index(op.f('ix_canteens_qr_code'), 'canteens', ['qr_code'], unique=True)
    op.drop_column('canteens', 'lat')
    op.drop_column('canteens', 'slug')
    op.drop_column('canteens', 'default_ready_minutes')
    op.drop_column('canteens', 'lng')
    op.drop_column('canteens', 'settings')
    op.drop_column('canteens', 'working_hours')
    # Добавляем колонки сначала как nullable, затем заполняем и делаем NOT NULL
    op.add_column('menu_items', sa.Column('type', postgresql.ENUM('food', 'drink', name='menuitemtype', create_type=False), nullable=True))
    op.add_column('menu_items', sa.Column('price', sa.Integer(), nullable=True))
    
    # Заполняем значениями для существующих записей
    connection = op.get_bind()
    # Если есть category, преобразуем её в type
    connection.execute(sa.text("""
        UPDATE menu_items 
        SET type = CASE 
            WHEN category::text IN ('food', 'side', 'snack') THEN 'food'::menuitemtype
            WHEN category::text = 'drink' THEN 'drink'::menuitemtype
            ELSE 'food'::menuitemtype
        END,
        price = COALESCE(price_cents, 0)
        WHERE type IS NULL OR price IS NULL
    """))
    
    # Если type все еще NULL, устанавливаем дефолтное значение
    connection.execute(sa.text("""
        UPDATE menu_items 
        SET type = 'food'::menuitemtype,
            price = 0
        WHERE type IS NULL OR price IS NULL
    """))
    
    # Теперь делаем колонки NOT NULL
    op.alter_column('menu_items', 'type', nullable=False)
    op.alter_column('menu_items', 'price', nullable=False)
    op.alter_column('menu_items', 'description',
               existing_type=sa.VARCHAR(),
               type_=sa.Text(),
               existing_nullable=True)
    op.alter_column('menu_items', 'available',
               existing_type=sa.BOOLEAN(),
               nullable=False)
    op.drop_column('menu_items', 'extra_data')
    op.drop_column('menu_items', 'category')
    op.drop_column('menu_items', 'price_cents')
    op.drop_column('menu_items', 'sku')
    op.drop_column('menu_items', 'position')
    op.drop_column('menu_items', 'currency')
    op.add_column('orders', sa.Column('food_id', sa.UUID(), nullable=True))
    op.add_column('orders', sa.Column('drink_id', sa.UUID(), nullable=True))
    op.alter_column('orders', 'user_id',
               existing_type=sa.UUID(),
               nullable=False)
    op.alter_column('orders', 'status',
               existing_type=postgresql.ENUM('pending', 'preparing', 'ready', 'collected', 'cancelled', 'completed', name='orderstatus'),
               nullable=False)
    op.create_index(op.f('ix_orders_status'), 'orders', ['status'], unique=False)
    # Внешний ключ postamat_id уже удален выше, перед удалением таблицы postamats
    # Проверяем, существует ли еще, и удаляем, если есть
    connection = op.get_bind()
    result = connection.execute(sa.text("""
        SELECT constraint_name 
        FROM information_schema.table_constraints 
        WHERE table_name = 'orders' 
        AND constraint_name = 'orders_postamat_id_fkey'
    """))
    if result.fetchone():
        op.drop_constraint('orders_postamat_id_fkey', 'orders', type_='foreignkey')
    op.create_foreign_key(None, 'orders', 'menu_items', ['drink_id'], ['id'])
    op.create_foreign_key(None, 'orders', 'menu_items', ['food_id'], ['id'])
    op.drop_column('orders', 'note')
    op.drop_column('orders', 'pickup_method')
    op.drop_column('orders', 'ready_at')
    op.drop_column('orders', 'payment_status')
    op.drop_column('orders', 'source')
    op.drop_column('orders', 'queue_number')
    op.drop_column('orders', 'ordered_at')
    op.drop_column('orders', 'total_cents')
    op.drop_column('orders', 'currency')
    op.drop_column('orders', 'postamat_id')
    # Добавляем колонки сначала как nullable, затем заполняем и делаем NOT NULL
    op.add_column('users', sa.Column('password_hash', sa.String(), nullable=True))
    op.add_column('users', sa.Column('role', postgresql.ENUM('USER', 'CANTEEN', 'ADMIN', name='userrole', create_type=False), nullable=True))
    
    # Заполняем значениями для существующих записей
    connection = op.get_bind()
    # Если есть hashed_password, копируем его в password_hash
    result = connection.execute(sa.text("""
        SELECT column_name 
        FROM information_schema.columns 
        WHERE table_name = 'users' 
        AND column_name = 'hashed_password'
    """))
    if result.fetchone():
        connection.execute(sa.text("""
            UPDATE users 
            SET password_hash = hashed_password,
                role = 'USER'::userrole
            WHERE password_hash IS NULL OR role IS NULL
        """))
    else:
        # Если hashed_password нет, устанавливаем дефолтные значения
        connection.execute(sa.text("""
            UPDATE users 
            SET password_hash = '$2b$12$default_hash_that_should_be_changed',
                role = 'USER'::userrole
            WHERE password_hash IS NULL OR role IS NULL
        """))
    
    # Если password_hash или role все еще NULL, устанавливаем дефолтные значения
    connection.execute(sa.text("""
        UPDATE users 
        SET password_hash = COALESCE(password_hash, '$2b$12$default_hash_that_should_be_changed'),
            role = COALESCE(role, 'USER'::userrole)
        WHERE password_hash IS NULL OR role IS NULL
    """))
    
    # Теперь делаем колонки NOT NULL
    op.alter_column('users', 'password_hash', nullable=False)
    op.alter_column('users', 'role', nullable=False)
    op.add_column('users', sa.Column('canteen_id', sa.UUID(), nullable=True))
    op.alter_column('users', 'is_active',
               existing_type=sa.BOOLEAN(),
               nullable=False)
    op.create_index(op.f('ix_users_canteen_id'), 'users', ['canteen_id'], unique=False)
    op.create_index(op.f('ix_users_phone'), 'users', ['phone'], unique=True)
    op.create_index(op.f('ix_users_role'), 'users', ['role'], unique=False)
    op.create_foreign_key(None, 'users', 'canteens', ['canteen_id'], ['id'])
    op.drop_column('users', 'hashed_password')
    op.drop_column('users', 'is_staff')
    op.drop_column('users', 'profile_data')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('profile_data', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True))
    op.add_column('users', sa.Column('is_staff', sa.BOOLEAN(), autoincrement=False, nullable=True))
    op.add_column('users', sa.Column('hashed_password', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.drop_constraint(None, 'users', type_='foreignkey')
    op.drop_index(op.f('ix_users_role'), table_name='users')
    op.drop_index(op.f('ix_users_phone'), table_name='users')
    op.drop_index(op.f('ix_users_canteen_id'), table_name='users')
    op.alter_column('users', 'is_active',
               existing_type=sa.BOOLEAN(),
               nullable=True)
    op.drop_column('users', 'canteen_id')
    op.drop_column('users', 'role')
    op.drop_column('users', 'password_hash')
    op.add_column('orders', sa.Column('postamat_id', sa.UUID(), autoincrement=False, nullable=True))
    op.add_column('orders', sa.Column('currency', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.add_column('orders', sa.Column('total_cents', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('orders', sa.Column('ordered_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True))
    op.add_column('orders', sa.Column('queue_number', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('orders', sa.Column('source', postgresql.ENUM('web', 'qr', 'postamat', name='ordersource'), autoincrement=False, nullable=True))
    op.add_column('orders', sa.Column('payment_status', postgresql.ENUM('unpaid', 'paid', 'refunded', name='paymentstatus'), autoincrement=False, nullable=True))
    op.add_column('orders', sa.Column('ready_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True))
    op.add_column('orders', sa.Column('pickup_method', sa.VARCHAR(), autoincrement=False, nullable=False))
    op.add_column('orders', sa.Column('note', sa.TEXT(), autoincrement=False, nullable=True))
    op.drop_constraint(None, 'orders', type_='foreignkey')
    op.drop_constraint(None, 'orders', type_='foreignkey')
    op.create_foreign_key('orders_postamat_id_fkey', 'orders', 'postamats', ['postamat_id'], ['id'])
    op.drop_index(op.f('ix_orders_status'), table_name='orders')
    op.alter_column('orders', 'status',
               existing_type=postgresql.ENUM('pending', 'preparing', 'ready', 'collected', 'cancelled', 'completed', name='orderstatus'),
               nullable=True)
    op.alter_column('orders', 'user_id',
               existing_type=sa.UUID(),
               nullable=True)
    op.drop_column('orders', 'drink_id')
    op.drop_column('orders', 'food_id')
    op.add_column('menu_items', sa.Column('currency', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.add_column('menu_items', sa.Column('position', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('menu_items', sa.Column('sku', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.add_column('menu_items', sa.Column('price_cents', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('menu_items', sa.Column('category', postgresql.ENUM('food', 'drink', 'side', 'snack', name='menucategory'), autoincrement=False, nullable=False))
    op.add_column('menu_items', sa.Column('extra_data', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True))
    op.alter_column('menu_items', 'available',
               existing_type=sa.BOOLEAN(),
               nullable=True)
    op.alter_column('menu_items', 'description',
               existing_type=sa.Text(),
               type_=sa.VARCHAR(),
               existing_nullable=True)
    op.drop_column('menu_items', 'price')
    op.drop_column('menu_items', 'type')
    op.add_column('canteens', sa.Column('working_hours', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True))
    op.add_column('canteens', sa.Column('settings', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True))
    op.add_column('canteens', sa.Column('lng', sa.NUMERIC(precision=9, scale=6), autoincrement=False, nullable=True))
    op.add_column('canteens', sa.Column('default_ready_minutes', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('canteens', sa.Column('slug', sa.VARCHAR(), autoincrement=False, nullable=False))
    op.add_column('canteens', sa.Column('lat', sa.NUMERIC(precision=9, scale=6), autoincrement=False, nullable=True))
    op.drop_index(op.f('ix_canteens_qr_code'), table_name='canteens')
    op.create_index('ix_canteens_slug', 'canteens', ['slug'], unique=False)
    op.alter_column('canteens', 'description',
               existing_type=sa.Text(),
               type_=sa.VARCHAR(),
               existing_nullable=True)
    op.drop_column('canteens', 'is_active')
    op.drop_column('canteens', 'qr_code')
    op.create_table('subscriptions',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('plan_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('status', postgresql.ENUM('active', 'past_due', 'canceled', 'trialing', name='subscriptionstatus'), autoincrement=False, nullable=True),
    sa.Column('started_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('current_period_end', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('stripe_subscription_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['plan_id'], ['plans.id'], name='subscriptions_plan_id_fkey'),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name='subscriptions_user_id_fkey'),
    sa.PrimaryKeyConstraint('id', name='subscriptions_pkey')
    )
    op.create_table('order_items',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('order_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('menu_item_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('price_cents', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('quantity', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['menu_item_id'], ['menu_items.id'], name='order_items_menu_item_id_fkey'),
    sa.ForeignKeyConstraint(['order_id'], ['orders.id'], name='order_items_order_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='order_items_pkey')
    )
    op.create_table('postamats',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('address', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('city', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('lat', sa.NUMERIC(precision=9, scale=6), autoincrement=False, nullable=True),
    sa.Column('lng', sa.NUMERIC(precision=9, scale=6), autoincrement=False, nullable=True),
    sa.Column('code', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='postamats_pkey')
    )
    op.create_table('plans',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('slug', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('description', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('price_cents', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('interval', postgresql.ENUM('month', 'year', 'weekly', name='planinterval'), autoincrement=False, nullable=True),
    sa.Column('trial_days', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('features', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('stripe_price_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='plans_pkey'),
    sa.UniqueConstraint('slug', name='plans_slug_key', postgresql_include=[], postgresql_nulls_not_distinct=False)
    )
    op.drop_index(op.f('ix_user_subscriptions_user_id'), table_name='user_subscriptions')
    op.drop_index(op.f('ix_user_subscriptions_is_active'), table_name='user_subscriptions')
    op.drop_table('user_subscriptions')
    op.drop_index(op.f('ix_payments_user_id'), table_name='payments')
    op.drop_table('payments')
    op.drop_table('subscription_packages')
    # ### end Alembic commands ###
